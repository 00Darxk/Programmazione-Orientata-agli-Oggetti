\documentclass{article}

\usepackage{cancel}
\usepackage{amsmath}
\usepackage[includehead,nomarginpar]{geometry}
\usepackage{graphicx}
\usepackage{amsfonts} 
\usepackage{verbatim}
\usepackage{mathrsfs}  
\usepackage{lmodern}
\usepackage{braket}
\usepackage{bookmark}
\usepackage{fancyhdr}
\usepackage{romanbarpagenumber}
\usepackage{minted}
\usepackage[italian]{babel}
\allowdisplaybreaks

\setlength{\headheight}{12.0pt}
\addtolength{\topmargin}{-12.0pt}

\hypersetup{
    colorlinks=true,
    linkcolor=black,
}

\makeatother

\numberwithin{equation}{subsection}

\fancypagestyle{link}{\fancyhf{}\renewcommand{\headrulewidth}{0pt}\fancyfoot[C]{Sorgente del file LaTeX disponibile al seguente link: \url{https://github.com/00Darxk/Programmazione-Orientata-agli-Oggetti}}}

\begin{document}

\title{%
    \textbf{Programmazione Orientata agli Oggetti}  \\ 
    \large Appunti delle Lezioni di Programmazione Orientata agli Oggetti \\
    \textit{Anno Accademico: 2023/24}}
\author{\textit{Giacomo Sturm}}
\date{\textit{Dipartimento di Ingegneria Civile, Informatica e delle Tecnologie Aeronautiche \\
Università degli Studi ``Roma Tre"}}

\maketitle
\thispagestyle{link}

\clearpage

\pagestyle{fancy}
\fancyhead{}\fancyfoot{}
\fancyhead[C]{\textit{Programmazione Orientata agli Oggetti - Università degli Studi ``Roma Tre"}}
\fancyfoot[C]{\thepage}
\pagenumbering{Roman}

\tableofcontents

\clearpage

\pagenumbering{arabic}

%% TODO: fix order of contents / merge (sub)section
%% TODO programma ppt. -> README
%% TODO testi di riferimento


\section{Introduzione al Linguaggio Java}

Java venne introdotto nel 1995, progettato per programmare dispositivi embedded, ma velocemente si utilizzò per scopi diversi da quelli descritti dai suoi 
creatori. Il team di Java sviluppò un sistema di embedded per i browser, le applet, delle piccole applicazioni che potevano essere eseguite all'interno 
del browser. Questo fu uno dei primi motivi per il successo di Java, un'altro aspetto importante per la diffusione di Java fu la sua caratteristica di 
semplificare aspetti di C e C++. Utilizzando un linguaggio più semplice diminuiva il costo associato ad un programmatore, per cui l'adozione di Java 
venne trainata dalle aziende alla ricerca di abbassare gli stipendi dei suoi dipendenti. In seguito venne utilizzato per creare la macchina virtuale su 
cui operano tutti i dispositivi Android. 

Java è stato ideato con la capacità di mantenere la retro-compatibilità, nonostante le spinte di innovazione tecnologica che il linguaggio ha sostenuto 
negli anni. Nonostante la sua età Java è uno dei linguaggi di programmazione più usati dalle aziende. 
La diffusione più importante di Java si ebbe tra il '95 ed il '98. 


Java fu il primo progetto industriale che introdusse un nuovo concetto di portabilità, un processore virtuale, poiché non viene progettato per un 
calcolatore fisico, ma la piattaforma ``Java Virtual Machine'', JVM. Uno stesso programma Java può essere eseguito su tutte le piattaforme senza dover ricompilare 
nuovamente il codice per quella specifica piattaforma. Questa rappresenta una rivoluzione in ambito industriale, il codice oggetto Java ``bytecode'' prodotto dalla 
compilazione, come un file di estensione \verb|.class|, può quindi essere eseguito da qualsiasi piattaforma che dispone di un'implementazione della 
JVM. Invece programmi creati da un linguaggio più vecchio come C, producono un codice oggetto che presenta istruzioni macchina uniche alla piattaforma in cui è stato 
compilato. Astraendo il processore fisico si è reso possibile la creazione di programmi che non devono essere ricompilati per ogni piattaforma su cui deve essere eseguito. 

Gli applet realizzati tramite Java, venivano eseguiti dalla JVM, e permise la creazione di primi siti web, rivoluzionando il paradigma di programmazione dell'epoca. 
La sintassi e la semantica del linguaggio sono descritte in un documento noto come ``Java Language Specification'' o JLS, per risolvere eventuali ambiguità. Inoltre fu uno dei primi 
linguaggi ad aver introdotto librerie incluse insieme al compilatore, sulla piattaforma Java. 

\subsection{Rapporto con il Linguaggio C}

Il linguaggio C viene descritto come un linguaggio di programmazione di medio livello, di alto livello rispetto all'assembly, e permette di realizzare programmi ad alte 
prestazioni, utilizzato quindi per scrivere sistemi operativi. Java invece venne introdotto in un ambiente diverso rispetto al linguaggio C, molto più evoluto dove le prestazioni non 
rappresentavano l'unico criterio di valutazione, grazie all'aumento delle prestazioni dei calcolatori. Questo permise di realizzare linguaggi, ad alto livello di astrazione, che non avessero 
come scopo principale il risparmiare risorse del sistema.
Non è un linguaggio che cerca le migliori prestazioni, ma cerca di creare programmi semplici e portabili. Il linguaggio 
C++ permette di avere prestazioni simili al linguaggio C, ma introducendo paradigmi introdotti in Java. Ma si preferisce per realizzare programmi ad alte prestazioni il 
C, rispetto al C++, poiché rimane un linguaggio molto complesso, complicando l'implementazione e l'uso del linguaggio. 



In Java una dichiarazione di una variabile comprende la sua inizializzazione ad un valore nullo, al contrario di C. Le dichiarazioni e assegnazioni in Java si ottengono mediante la stessa 
sintassi del linguaggio C. Si introduce un tipo \verb|boolean| utilizzato per rappresentare i due possibili valori booleani \verb|true| e \verb|false|. Le descrizioni di 
tutti i tipi utilizzati in Java vengono definite nel JLS. Entrambi sono due linguaggi staticamente tipati, ovvero a tempo di compilazione deve essere noto il tipo di ogni 
dato utilizzato nel programma. 
Java introduce il tipo \verb|String| utilizzato per rappresentare stringhe, non è un dato primitivo, e permette l'uso molto più semplice delle stringhe rispetto a C. Rappresenta 
un tipo particolare di classe, appoggiato dal compilatore per migliorare le sue prestazioni. Le stringhe vengono inizializzate a letterali stringhe, 
contenuti tra due doppi apici \verb|"  "|. Da Java 13 è possibile scrivere stringhe letterali multi-linea, utilizzando tripli doppi apici \verb|"""   """|. 
L'uso molto più semplificato delle stringhe in Java rispetto a C rappresenta uno dei motivi principali per cui è stato possibile convertire molti programmatori dall'uso di C a Java dopo la 
sua introduzione. 

La sintassi di controlli di flusso è esattamente la stessa del linguaggio C, ma le condizioni sono diverse a causa del tipo booleano. 

Una grande differenza tra i due linguaggi consiste nella diversa diagnostica a tempo di compilazione e di esecuzione degli errori, poiché in Java gli errori ed i messaggi 
di errore forniscono informazioni molto utili per la sua risoluzione. 
Gli errori a tempo di compilazione sono altrettanto efficaci in Java quanto in C, ma  la differenza principale consiste negli errori a tempo di esecuzione tra i due linguaggi, 
poiché in C, su molte piattaforme, viene fornito un errore estremamente generico, in base alla versione di C, del compilatore, e da altre condizioni. 
Mentre in Java esistono numerosi errori, chiamati eccezioni per definire ogni possibile tipo di errore. 

\subsection{Paradigma Orientato agli Oggetti}

Il paradigma procedurale, usato nel linguaggio C, separa in maniera netta il codice e le operazioni, ovvero la memoria e ed il processore, seguendo l'architettura 
definita da von Neumann. Anche se rappresenta il modo più naturale per scrivere programmi, nell'industria è stato ampiamente superato a favore del paradigma orientato agli 
oggetti. 
Questo paradigma segue la filosofia secondo cui le operazioni e lo stato sono connesse tra di loro, accomunate utilizzando ``oggetti''. Si è quindi rimossa la divisione imposta 
sui vecchi linguaggi di programmazione, che seguono l'architettura reale di un calcolatore. Per cui un problema è più facilmente modellabile se viene diviso in una pluralità 
di oggetti e classi di oggetti, contenenti lo stato e le operazione eseguibili su quell'oggetto. Questi oggetti si scambiano informazioni tra di loro, invocando particolari 
comandi; in questo modo gli oggetti conoscono ed interagiscono con altri esemplari, anche dello stesso tipo, o classe. Per conoscersi, questi oggetti contengono riferimenti 
agli altri oggetti. 

Questo modo di interpretare un problema è vicino al nostro modo di pensare, il che aiuta nella creazione di programmi utilizzando linguaggi orientati agli oggetti. 
Utilizzando un linguaggio come C, progettato per il paradigma procedurale, è possibile programmare seguendo il paradigma orientato agli oggetti, ma non essendo 
stato creato con questo scopo, la realizzazione di programmi utilizzando questo paradigma è notevolmente più complesso. 


L'esecuzione di un programma è uno scambio di messaggi tra questi oggetti connessi tra di loro tramite riferimenti interni, creando una rete di oggetti, modificando lo stato 
degli oggetti coinvolti nelle operazioni. Si può rappresentare la rete di oggetti tramite un diagramma di oggetti, indicati come rettangoli contenenti diversi campi, ed 
eventuali riferimenti ad altri oggetti, rappresentati come archi orientati, diretti verso altri oggetti.  

Ogni oggetto contiene lo stato, un comportamento, le operazioni che offre ed un identità, per differenziare diversi esemplari della stessa classe di oggetti. Si è dimostrato 
nel tempo come questo paradigma permette di scrivere e mantenere il codice molto più efficiente rispetto ad altri paradigmi. 
Gli oggetti vengono definiti tramite classi, rappresentate come file diversi del programma, contenenti lo stato, e la definizione dei metodi. Ogni oggetto creato da una classe 
possiede un'identità unica, e presenta lo stesso stato e le operazioni della classe di appartenenza. Le classi sono quindi delle istruzioni di montaggio, o fabbriche che 
producono oggetti. 


Per studiare questo paradigma, si utilizzeranno esempi di forme geometriche, come studio di caso più semplice e limitato, ed uno studio di caso più esteso, mirato al 
refactoring, chiamato ``diadia''. 


In Java ogni file contenente classi deve essere salvato con lo stesso nome della classe contenente, in un file di estensione ``.java''. Le operazioni di oggetti in Java si chiamano 
metodi, invece di funzioni come nel linguaggio C, poiché rappresentano operazioni nel contesto di una classe, mentre le funzioni possono operare al di fuori di una classe. 

\subsection{Oggetti e Riferimenti}

Ogni classe viene definita utilizzando la parola chiave \verb|class| seguito dal nome della classe, il corpo di questa contiene le definizioni dei metodi e delle variabili di istanza 
della stessa, che memorizzano le informazioni dello stato di un oggetto di questo tipo. Nella definizione della classe viene usato il modificatore di visibilità \verb|public|, analogamente 
ai metodi ed alle variabili di istanza:
\begin{minted}{java}
    public class <nomeClasse> {
        // definizioni delle variabili e dei metodi
    }
\end{minted} 
Per cui ogni definizione utilizza un modificatore di visibilità seguendo la sintassi: modificatore di visibilità, tipo, nome della variabile o metodo o classe. Questo 
modificatore di visibilità verrà trattato più approfonditamente in una sezione successiva, ma in generale descrive se una certa variabile, metodo o classe è visibile 
all'esterno del file stesso dove viene dichiarata. 

Per iniziare l'esecuzione di un programma viene eseguito il metodo \verb|main()|, ereditato da C, invocato sempre per primo dalla JVM, da cui quindi parte l'esecuzione di ogni altro metodo 
utilizzato nell'esecuzione. Quindi eccetto questo metodo, per ogni altra invocazione di un metodo esiste sempre un metodo invocante ed un metodo invocato. 



Si considera un esempio semplice di una classe chiamata \verb|Punto|, che rappresenta un punto in un piano di coordinate cartesiane bidimensionali:
\begin{minted}{java}
public class Punto{
    // stato dell'oggetto
    private int x;
    private int y;

    // metodi propri della classe
    public void setX(int posX){
        this.x = posX;
    }
    public void setY(int posY){
        this.y = posY;
    }
    public int getX(){
        return x;
    }
    public int getY(){
        return y;
    }
}
\end{minted}
Le variabili della classe \verb|Punto| \verb|x| e \verb|y|, vengono chiamate variabili d'istanza. La creazione di un oggetto di una classe si ottiene tramite l'operatore \verb|new|, 
secondo la seguente sintassi:
\begin{minted}{java}
// creazione ed assegnazione di un nuovo oggetto Punto tramite riferimento
Punto origine = new Punto();
\end{minted}
Questa riga di codice invoca un costruttore tramite l'operatore \verb|new|, restituisce un riferimento ad un oggetto del tipo \verb|Punto| appena creato, e viene conservato 
con un'assegnazione ad una variabile locale, in questo caso chiamata \verb|origine|. 

Tramite questo riferimenti è possibile accedere ai metodi, ed eventualmente allo stato dell'oggetto, tramite la notazione puntata, che segue la sintassi 
\verb|<rif-obj>.<metodo>(<par-attuali>);|:  
\begin{minted}{java}
origine.setX(0); // assegna lo stato alla variabile x
origine.setY(0); // assegna lo stato alla variabile y
\end{minted}
Questa notazione è molto efficace nell'esprimere la vicinanza tra i dati e le operazioni, per cui viene ampiamente usata in tutti i linguaggi OO (Orientati agli Oggetti). 
Ogni nuovo oggetto creato viene salvato in memoria, ed è possibile creare nuovi oggetti fino all'esaurimento della memoria virtuale. 
Questa classe viene quindi contenuta in un file \verb|Punto.java|. 



Una variabile contenente un riferimento ad un oggetto contiene una sequenza di caratteri che rappresenta l'indirizzo in memoria virtuale dell'oggetto, anche se rappresenta una 
semplificazione, è utile per analizzare il suo comportamento. Mentre per accedere ai valori contenuti, ed assegnare valori alle variabili interne all'oggetto, bisogna utilizzare 
metodi ``getter'' e ``setter'', descritti nella classe dell'oggetto, poiché le variabili di istanza sono accessibili solamente all'interno della classe. 

Quando viene chiamato un metodo passando una variabile, viene passato per valore. 

In Java il riferimento nullo è un unicamente il letterale di tipo riferimento all'oggetto \verb|null|. Ogni riferimento ad oggetto dichiarato, senza essere inizializzato 
viene assegnato al riferimento nullo. Indica l'assenza di un riferimento reale ad un oggetto esistente, al contrario del riferimento nullo in C, non corrisponde all'intero $0$. 
Invocando un metodo su un riferimento ad un oggetto nullo si verifica un errore, a tempo di esecuzione, si indica in Java come eccezione: ``runtime-exception''; in questo caso: 
\verb|NullPointerException|. 

Nel corpo dei metodi, se il nome di un parametro formale coincide al nome di una variabile di istanza, il primo ha precedenza, lo offusca. Si verifica l'effetto di ``shadowing'', per cui 
vengono effettuate operazioni non sulla variabile di istanza, ma sul parametro formale. Per identificare le variabile di istanza si utilizza la parola chiave \verb|this|, in notazione 
puntata seguita dal nome della variabile di interesse. In questo modo si possono utilizzare come nomi di parametri formali gli stessi nomi di una variabile di istanza, senza 
problemi. 
La parola chiave \verb|this| rappresenta infatti un riferimento all'oggetto corrente, anche se viene usato per accedere alle variabili di istanza, può essere omesso in assenza di ambiguità 
con i parametri formali. Viene comunque favorito il suo utilizzo per aumentare la leggibilità del codice ed evitare eventuali fenomeni di shadowing. 
Può essere inoltre utilizzato per invocare metodi propri della classe, all'interno di altri metodi della stessa. 

\subsection{Gestione della Memoria}

In Java la creazione di oggetti, e quindi la loro allocazione in memoria, avviene tramite l'operatore \verb|new|. Questo operatore richiede la specifica della classe di cui si 
vuole creare una nuova istanza, e richiede uno dei costruttori della classe. 
Un costruttore è un metodo che presenta esattamente lo stesso nome della classe e non restituisce niente, e generalmente inizializza tutte le variabili di istanza della classe, ma non 
sono dei metodi per cui non devono specificare il tipo del valore restituito, neanche utilizzando \verb|void|.  

\begin{minted}{java}
public class Punto{
    private int x;
    private int y;
    // costruttore "no-args" della classe "Punto"
    public Punto(){
        this.x = 0;
        this.y = 0;
    }
}
\end{minted}
Questo tipo di costruttori non prendono parametri, ma è possibile definire costruttori che accettano degli input. Ogni classe presenta sempre almeno un costruttore, e 
costruisce lo stato iniziale dell'oggetto, per cui è possibile inizializzare l'oggetto ad un certo stato fornito alla chiamata del costruttore:
\begin{minted}{java}
public class Punto{
    private int x;
    private int y;
    // costruttore della classe "Punto"
    public Punto(int x, int y){
        this.x = x;
        this.y = y;
    }
}
\end{minted}

L'oggetto è stato creato, e lo stato inizializzato, solamente al termine dell'esecuzione del costruttore, durante la sua esecuzione lo stato dell'oggetto è inconsistente.  

Poiché una classe può contenere più di un costruttore, questi vengono distinti in base agli argomenti che prendono. 
Se invece non viene dichiarato alcune costruttore all'interno di una classe, è possibile creare un nuovo oggetto usando la stessa terminologia, e tutti i campi numerici 
vengono inizializzati a zero, i riferimenti a null, e le stringhe alla stringa vuota. Per cui il compilatore crea automaticamente un compilatore ``no-args'' con le inizializzazioni 
di default, ma se viene dichiarato un costruttore con parametri all'interno di una classe, e si prova a creare un oggetto della classe usando un costruttore no-args il 
compilatore produce un errore. Quindi il compilatore genera un costruttore implicito solamente se non è dichiarato alcun costruttore dentro una classe. 
Spesso si definiscono diversi costruttore per inizializzare uno oggetto della stessa classe in diversi stati noti. 

Durante l'esecuzione la JVM ha accesso a due aree di memoria, lo ``Stack'' e l'``Heap''. Lo stack contiene le informazioni necessarie all'esecuzione dei metodi, lo stato dell'esecuzione e le 
variabili locali ed il loro valore. Mentre l'heap contiene gli oggetti creati tramite l'operatore \verb|new|. 
All'inizio viene assegnato lo stack alla JVM, viene utilizzata per conservare ciò che è necessario a mantenere lo stato dell'esecuzione, è una struttura dati che implementa la disciplina 
LIFO, gestita dalla JVM, per memorizzare i metodi ed i Record Di Attivazione, o RDA, di questi, cominciando dal metodo \verb|main()|. 
Ogni volta che termina l'esecuzione di un metodo, viene rimosso dallo stack, gestito in modo automatico e trasparente rispetto dalla JVM. Dopo essere stato rimosso un metodo dallo stack, 
le variabili locali ed i suoi parametri non sono più utilizzabili. 

L'RDA contiene i parametri attuali, il riferimento all'oggetto corrente, i parametri locali, il valore restituito, ed il riferimento al metodo invocante. Contiene inoltre tutti gli 
identificatori delle variabili, più facile da ricordare rispetto all'indirizzo della variabile stessa. 
Il primo record di attivazione è sempre il metodo \verb|main()|. 

Poiché lo stack è di dimensione limitata, e generalmente piccola rispetto all'heap, per cui non può contenere troppi RDA, ed è possibile esaurire lo spazio, sollevando un'eccezione: 
\verb|StackOverflowException|. 


L'heap contiene tutti gli oggetti dichiarati con \verb|new|, la sua dimensione quindi varia a tempo di esecuzione per accomodare tutti questi oggetti ed il loro stato. Viene assegnata 
dalla JVM, dove gli oggetti vengono allocati in ordine sparso, quindi non rispettano alcuna disciplina FIFO o LIFO. L'operatore \verb|new| è quindi molto simile all'operatore \verb|malloc| in C, 
l'unica differenza è che il primo invoca un costruttore. 

Dati due riferimenti allo stesso oggetto, utilizzando uno dei due è possibile applicare modifiche all'oggetto, visibili anche dall'altro riferimento, questo fenomeno si chiama ``Side-Effect'', 
o effetto collaterale. 
Poiché gli oggetti si passano come riferimenti, l'operatore \verb|==| confronta solamente i riferimenti all'oggetto, e bisogna utilizzare un altro metodo per poter 
confrontare i valori interni degli oggetti tra di loro.  
Per determinare l'equivalenza tra due oggetti distinti si usa il metodo \verb|equals()|, viene offerto sempre da tutte le classi, se invece non viene espresso esplicitamente 
ha la stessa semantica dell'operatore \verb|==| sui riferimenti. 
Poiché è un metodo interno ad una classe, in generale non è un metodo simmetrico: \verb|a.equals(b)| $\neq$ \verb|b.equals(a)|. 
Questo metodo identifica l'equivalenza tra due oggetti distinti. 

La deallocazione della memoria avviene automaticamente da un metodo chiamato Garbage Collector, per cui non è necessario utilizzare esplicitamente una funzione \verb|free()| 
come in C. Se questo Garbage Collector si accorge che degli oggetti rimangono appesi, li libera dalla memoria. 

Il garbage collector analizza la catena di riferimenti degli oggetti per determinare se un dato oggetto è in uso, oppure non è più raggiungibile tramite una sequenza di riferimenti che 
parte dallo stato dell'esecuzione corrente. 

\subsection{Overloading, Stringhe e Array}

L'``Overloading'' è una caratteristica di un linguaggio di programmazione, come Java, che permette di definire più procedure con lo stesso nome, ospitati all'interno della stessa 
classe. Questi metodi, diversi, si distinguono solamente per il tipo, il numero di uno o più parametri formali, oppure per il loro ordine. Invece non è possibile distinguere due metodi 
solamente per il tipo di ritorno, in generale il tipo restituito non appartiene alla segnatura di un metodo. 

\begin{minted}{java}
public class Sommatore{
    public int add(int a, int b) { return a + b; }

    public int add(int a, int b, int c) { return a + b + c; }

    public double add(int a, double b) { return a + b; }

    public double add(double a, int b) { return a + b; }
}
\end{minted}

Nel linguaggio C, questo non è possibile. Se c'è una corrispondenza perfetta tra i parametri passati al metodo, non si riscontrano problemi, invece se non è presente 
una corrispondenza perfetta tra i tipi passati al metodo, viene invocato un algoritmo di risoluzione, prima di fermare la compilazione che cerca di capire se è possibile 
effettuare la chiamata tramite semplici conversioni di tipo, oppure conversioni di tipo più ``conservative''. La promozioni di tipo può essere implicita alla chiamata di un 
metodo, per cui potrebbe essere complesso determinare quale metodo è stato chiamato. 

Alla chiamata di un metodo sovraccaricato è il compilatore a scegliere quale dei metodi da applicare, la scelta è definitiva e viene scritta nell'eseguibile \verb|.class|. 
Versioni sovraccariche di un metodo potrebbero differire anche per il metodo di ritorno, ma il tipo di ritorno non può essere usato per distinguere due metodi. 

L'overloading è presente anche sull'operatore \verb|+|, applicandolo su diversi dati, tramite somme algebriche di interi, numerali a virgola mobile; inoltre viene usato per 
concatenare stringhe tra di loro. In C++ ed in Scala è possibile sovraccaricare gli altri operatori, mentre non è possibile in Java, dove l'unico operatore sovraccarico è \verb|+|, 
nella maniera descritta. 

Costruttori definiti ripetendo codice vengono sconsigliati, anche per i metodi sovraccaricati, per cui si tende ad eleggere un costruttore al ruolo di costruttore ``primario'', 
il più generico possibile, per evitare la duplicazione del codice. In seguito gli altri costruttori vengono definiti in base a questo costruttore, invocandolo, con il metodo \verb|this()|, 
specificando i parametri che si vuole modificare rispetto al costruttore primario. 

\begin{minted}{java}
public class Rettangolo{
    private int altezza;
    private int base;
    private Punto vertice;

    public Rettangolo(Punto v, int b, int h){
        this.vertice = v;
        this.base = b;
        this.altezza = h;
    }

    public Rettangolo(int b, int h) { this(new Punto(0,0), b, h); }

    public Rettangolo() { this(new Punto(0,0), 0, 0); }
}   
\end{minted}

L'overloading viene risolto a tempo di compilazione, dal compilatore, che applica una scelta definitiva, ed inserisce il metodo scelto nei file \verb|.class| generati. Per cui quest'analisi 
dipende solamente dai tipi statici dei parametri attuali, nell'invocazione del metodo, a tempo statico. 



In Java esiste la classe \verb|String| per poter rappresentare sequenze di caratteri immutabili, rappresenta un riferimento ad un oggetto istanza della classe \verb|String|, può contenere 
caratteri di Unicode 2.1, la versione di Unicode a 16 bit, capace di memorizzare la maggior parte dei simboli e caratteri alfabetici moderni ed ideogrammi.  
Per rendere il linguaggio più semplice questa classe possiede dei letterali appositi, ed è l'unico oggetto che può essere creato senza una \verb|new| esplicita. L'operatore 
\verb|==| su due stringhe verifica l'uguaglianza dei riferimenti, per cui per valutare l'equivalenza di contenuto tra due stringhe bisogna utilizzare il metodo \verb|equals()|. 

Poiché rappresenta una sequenza di caratteri immutabili, per modificare o aggiornare una stringa è necessario crearne una nuova stringa, altrimenti è possibile concatenare due 
stringhe utilizzando l'operatore \verb|+|, che rappresenta un nuovo oggetto stringa, sovrascritto sulla variabile utilizzata per memorizzarla. 
Per ottenere la lunghezza di una stringa si utilizza il metodo \verb|.length()|, per ottenere il carattere ad una determinata posizione si utilizza il carattere \verb|.charAt(int i)|. 
Il metodo \verb|.indexOf(char a)| fornisce la posizione di un carattere o il primo carattere di una sottostringa, per cui è un metodo sovraccarico, altrimenti restituisce -1. 
Per aggiornare una stringa si utilizza il metodo \verb|.replace(Stringa s1, Stringa s2)|, che restituisce un nuovo oggetto dove è stata la sottostringa \verb|s1| con la 
sottostringa \verb|s2|.  


Se viene eseguito il metodo \verb|println()| su un riferimento stampa il valore del riferimento, non il riferimento stesso. Definendo il metodo \verb|toString()| è possibile 
specificare cosa si vuole visualizzato quando viene chiamato il metodo di stampa a schermo. Un oggetto che possiede questo metodo può essere concatenato con una stringa, 
questo concatena la stringa con la string restituita dal metodo \verb|toString()|. 
Se non viene definito questo metodo, il suo comportamento standard implicito stampa l'indirizzo di memoria dell'oggetto, come per il metodo \verb|equals()|. 



Un array è una struttura dati che memorizza dati omogenei, per dichiarare un array si inserisce accanto al tipo oppure al nome della variabile \verb|[]|, si preferisce la prima 
per leggibilità. Sono oggetti per cui devono essere dichiarati con il metodo \verb|new|. Le operazioni di accesso e modifica di un array sono le medesime del linguaggio C, 
per ottenere la lunghezza di un array si utilizza il metodo \verb|.length()|. Da Java 5 è stato introdotto un modo per poter iterare su un array chiamato ``for-each'', senza gestire 
esplicitamente l'indice di iterazione: 
\begin{minted}{java}
    for(<tipo> <nome-variabile> : <nome-array>)
\end{minted}
In questo modo la variabile \verb|<nome-variabile>| itera su ogni elemento dell'array \verb|<nome-array>| dello stesso tipo \verb|<tipo>|. 


Per realizzare una costante si può utilizzare la parola chiave \verb|final|, per convenzione gli identificatori di una costante si scrivono in maiuscolo. Per i tipi primitivi 
rende costante la variabile, per gli oggetti rende costante il riferimento, ma non il suo contenuto. 
Invece per realizzare una variabile condivisa su tutti gli oggetti della stessa classe si utilizza la parola chiave \verb|static|. 

\clearpage

\section{Qualità del Codice}

\subsection{Librerie}

Come ogni linguaggio di programmazione, relativamente recente, Java contiene numerose librerie specializzate per risolvere diversi problemi. Per cui è necessario utilizzare in 
maniera efficace ed efficiente queste librerie, composte da classi. Bisogna quindi conoscere per nome le classi più importanti di queste librerie, e sapere come cercare ed usare 
altre classi. 
Non è necessario conoscere l'implementazione di una classe, ma solo l'interfaccia o API fornito. Queste informazioni vengono fornite tramite la documentazione associata ad ogni 
libreria, in formato HTML \verb|javadoc|, accessibili tramite un browser, oppure integrate all'interno dell'IDE. 
Per ogni classe viene fornito il suo nome, una descrizione generale della classe, dello scopo dei suoi costruttori e metodi, e valori di ritorno per i suoi costruttori e metodi. 
Non sono presenti invece tutti i campi e metodi privati, poiché non sono accessibili dall'esterno, né il suo codice, non necessario per il suo utilizzo. 

In caso si voglia creare una nuova classe, bisogna documentarla allo stesso modo delle classi fornite dalle librerie, per permettere il loro utilizzo, senza conoscere in 
dettaglio la sua implementazione. La documentazione di una classe dovrebbe includere il nome, un commento che descrive la caratteristiche generali e lo scopo della classe, la versione, 
il nome dei metodi e dei costruttori, una descrizione del suo scopo, i parametri di ritorno e passati al costruttore o metodo. 
La documentazione può essere generata automaticamente tramite un'utility chiamata \verb|javadoc|, contenuta in Eclipse, i marcatori utilizzati per definire i comandi si trovano 
esclusivamente all'interno  di un commento generato del genere \verb|/** <comandi> */|:
\begin{minted}{java}
/**
 * Nome-classe: breve descrizione della classe ed il suo scopo
 * 
 * @author      autore della classe
 * @see         riferimento ad altre classi
 * @version     versione corrente della classe
 */  
\end{minted}

I commenti per un metodo o un costruttore vengono inseriti prima subito prima del metodo o costruttore stesso. 
\begin{minted}{java}
/**
 * Commento che descrive scopo e caratteristiche del metodo o costruttore
 * 
 * @param nome-parametro    breve descrizione
 * @return                  valore di ritorno
 */
\end{minted}

La classi vengono raggruppate in \verb|package|, per mantenere insieme classi concettualmente e logicamente correlate. Permette di creare spazi di nomi per evitare conflitti, 
in oltre permette di definire domini di protezione. 
Una classe può accedere a tutte le classi presenti nello stesso \verb|package|, altrimenti per accedere a classi pubbliche di un altro pacchetto si può utilizzare il nome completo, 
anteponendo il nome del pacchetto, oppure importando la classe ed utilizzando direttamente il nome della classe. Le classi devono dichiarare la propria appartenenza ad un 
pacchetto tramite la dichiarazione \verb|package <nome-package>|, all'inizio del file. Una classe può appartenere a più di un pacchetto. Ogni pacchetto deve avere un nome univoco, 
di solito il nome comprende il nome del dominio Internet dell'organizzazione in ordine inverso. Una classe può essere usata al di fuori del pacchetto solamente se viene dichiarata 
pubblica, tramite un modificatore d'accesso \verb|public|, se viene omesso questo modificatore, è accessibile solamente alle classi interne allo stesso pacchetto.

Il nome di un pacchetto possiede una struttura gerarchica, questa struttura deve avere una corrispondenza diretta nel file system. 

\subsection{Coesione e Accoppiamento}

Il software evolve continuamente, viene modificato in continuazione, per estensioni, correzioni, mantenimento, etc., e se il costo di questa evoluzione è troppo elevato, il 
software viene gettato e viene implementato da zero. Questa evoluzione viene effettuata in tempi diversi da molte persone. 
Se il codice è di cattiva qualità, la sua manutenzione ha un costo relativamente alto. La qualità del codice dipende da due fattori importanti, la coesione e l'accoppiamento. 
L'accoppiamento tra due o più unità di un programma rappresenta l'impossibilità di modificare una sola unità senza l'eventuale modifica di altre unità accoppiate ad essa. 
Per cui si vuole evitare l'accoppiamento, per limitare il più possibile la modifica di ulteriori unità, poiché aumenterebbe esponenzialmente i costi di una singola modifica. 
Un sintomo del forte accoppiamento è la duplicazione del codice all'interno di un progetto. Un basso accoppiamento permette di capire il codice di una classe senza leggere 
i dettagli di tutte le altri a lei accoppiata, e quindi anche la modifica, senza modificare ulteriori unità. 

La coesione si riferisce al numero e all'eterogeneità dei compiti di cui una singola classe è responsabile. Se ogni unità è responsabile di un singolo compito, allora possiede 
un'elevata coesione. La coesione si applica alle classi, ai metodi ed anche ai pacchetti. Un'alta coesione permette di definire moduli aventi uno scopo preciso ed un compito ben 
definito. Questo favorisce la comprensione dei compiti di una classe, l'utilizzo di nomi appropriati, ed il riuso di classi e di metodi, rendendo la manutenzione meno costosa. 
Alta coesione e basso accoppiamento rappresentano due caratteristiche dello stesso concetto. 
Un'alta coesione di una classe si ottiene mantenendo lo scarso accoppiamento rispetto alle altre classi, analogamente lo scarso accoppiamento di una classe verso altre si ottiene tramite 
un'alta coesione. 

Per cui quando viene progettato il codice è utile pensare a quali cambiamenti futuri potranno essere richiesti, e come verrà usata la classe. 

Quando si vuole modificare il codice, avere basso accoppiamento ed alta coesione, porta a modificare un numero ristretto di classi, per cui si mira a dover modificare il minor numero possibile 
di classi. 

Viene distinta la qualità esterna ed interna di un codice, sulla base degli utilizzatori del codice, esterna, in base ai suoi requisiti, e degli sviluppatori del codice, interna, per 
valutar la manutenibilità del codice.  

La manutenzione del codice spesso richiede l'aggiunta di nuovo codice, questo eventualmente degrada il codice nella sua totalità, aumentando l'accoppiamento e diminuendo la 
coesione, portando ad un'eventuale riorganizzazione del codice. Questa operazione viene chiamata ``refactoring'', senza modificare la funzionalità del codice. Per mantenere 
la correttezza del codice viene associato a dei test che stabiliscono i suoi criteri di correttezza, usati per valutare la correttezza di implementazioni interne diverse. 

In generale un metodo è troppo lungo se è responsabile di più di un compito logico, mentre una classe è troppo lunga se comprende più di un concetto. 

\subsection{Tecniche di Testing}

In generale i primi errori in un programma sono errori di sintassi, indicati dal compilatore in modo preciso e completo, anche se le specifiche di un messaggio di errore 
dipendono dal compilatore utilizzato, successivamente possono presentarsi errori logici o ``bug'', su cui il compilatore non è in grado di fornire indicazioni. 
Alcuni errori logici non si presentano immediatamente, per la complessità del software, altri possono essere individuati a tempo di esecuzione, e la macchina virtuale 
fornisce informazioni precise sulla natura dell'errore, la maggior parte delle volte si tratta di un'eccezione del tipo \verb|NullPointerException|. 

Un programma rappresenta una singola descrizione statica associata a molteplici possibili esecuzioni dinamiche. Il compilatore è in grado di individuare errori a livello statico, 
a tempo di scrittura o compilazione, e non è in grado di individuare possibili errori dovuti all'esecuzione e l'evoluzione del programma. 
I bug sono quindi errori che si presentano durante l'evoluzione dinamica del programma, che il compilatore non è in grado di prevedere. Il costo delle operazioni di debugging, 
rappresenta il costo principale di ogni moderno progetto di software, ed è interamente a carico del programmatore. 

La correzione di un bug dipende da due grandezze, la dimensione del contesto, ovvero il numero di linee di codice in cui il bug si può annidare. Inoltre dipende dal tempo 
necessario al bug per manifestarsi, rappresenta una misura temporale tra la causa del bug ed il rilevamento dei suoi effetti. 


Per rilevare i malfunzionamenti di un software vengono utilizzati delle tipologie di test, in tre fasi sequenziali:
\begin{itemize}
    \item Mettere il sistema in uno stato iniziale noto;
    \item Iniziare a sollecitare il sistema;
    \item Controllare lo stato del sistema e confrontarlo con lo stato atteso. 
\end{itemize}

Se i test sono progettati e mantenuti, allora permettono di individuare tempestivamente i bug all'interno del software, restringendo le cause del singolo bug. Se il test ha 
successo si ha una garanzia sul comportamento dinamico del codice, altrimenti fornisce informazioni sulla presenza di un bug. 
Ad ogni modifica è necessario ripetere un'operazione di testing, per identificare eventuali bug, inseriti durante la manutenzione del codice, in questo modo è possibile 
ricercare localmente l'errore, in maniera molto economica. Inoltre utilizzando questo processo è possibile prevenire la regressione, localizzando l'errore nel codice appena 
aggiunto al programma. 


Per automatizzare questo processo si realizza, accanto al codice di produzione, il codice di test. Una possibile soluzione inizializza tutti i casi da testare sul codice 
di produzione, inserendo, ad ogni chiamata, il valore atteso confrontandolo con il valore ottenuto. 
I test devono essere automatici, efficienti ed isolati, per mantenere la località degli errori, inoltre devono essere separati dal codice applicativo ed eseguibili e 
verificabili separatamente. 
Esistono vari strumenti per assistere il programmatore nel testing, in particolare l'unit-testing, in Java il più note ed utilizzato framework è ``JUnit'', integrato 
all'interno di Eclipse. 
Per ogni classe creata si crea una classe parallela dedicata al testing, contenente una batteria di test, ognuno un metodo differente per testare diversi casi, preceduto 
dall'annotazione \verb|@Test|, contenente un'asserzione sul risultato aspettato tramite il metodo \verb|assertEquals()|, e prende come parametri i due oggetti da confrontare tipati 
\verb|Object|. 

Tutte le classi di test hanno la stessa struttura, si inseriscono nello stesso pacchetto della classe che devono testare, e vengono chiamate rispettando la convenzione 
\verb|test<nome-classe>|, anche se non è più necessario utilizzare questa notazione, semplicemente tramite l'annotazione \verb|@Test|, anche se viene favorito il suo 
utilizzo. I risultati attesti sono documentati tramite asserzioni esplicite, non mediante stampe, se l'asserzione è vera il test è andato a buon fine, altrimenti è 
presente un errore nella sezione di codice testato. Sono possibili altre asserzioni fornite da JUnit, sovraccariche e facilmente intercambiabili, per cui è sempre 
favorito utilizzare la versione più pertinente. 

Una variante di \verb|assertEquals()|, prevede una stringa, da stampare per fornire informazioni sul risultato del test solo in caso di fallimento, oltre ai due riferimenti ad oggetti da 
comparare. 

Per compilare i test bisogna includere le librerie della versione di JUnit utilizzata nel classpath del progetto. JUnit è così popolare che viene incluso ed è fortemente integrato 
negli IDE moderni, come Eclipse. Questi favoriscono la creazione e l'uso dei test. In Eclipse un test eseguito può essere identificato da barre colorate, verde se il test ha avuto successo, 
rosso se il test è fallito sollevando un'eccezione o blu se il test ha fallito l'asserzione. 
Per favorire l'utilizzo dei test è possibile collocare le classi test in una cartella sorgente parallela a \verb|src| nella struttura delle classi. In questo modo si crea una copia del codice 
di produzione, adibita esclusivamente alla gestione delle classi di test. 

Per facilitare la scrittura di tutti i metodi di test, è comodo utilizzare degli oggetti predisposti per l'utilizzo da parte di tutti i test-case operazione chiamata 
Fixture. JUnit permette di confinare in un unico metodo \verb|setUp()| la creazione di tutti gli stati noti a priori tramite l'annotazione \verb|@BeforeEach|. 
In questo modo i test diventano estremamente semplici. 
In generale per non aumentare l'accoppiamento delle classi di test, è consigliabile includere nel metodo \verb|setUp| la creazione di oggetti utilizzati da almeno due test-case distinti. 
Altrimenti è preferibile mantenere la creazione di oggetti nel singolo test, per mantenere il test isolato, e diminuire l'accoppiamento nella classe. 

La lunghezza ottimale di un singolo test-case consiste di una singola riga di codice, rappresentata dall'asserzione. Per favorire la semplicità dei test si può 
fattorizzare il codice di creazione della fixture. 
L'uso di test minimali favorisce la leggibilità e la ricerca di errori, ed è sempre conveniente partire da test minimali per individuare i bug minori, per poi 
aumentare la complessità dei test ed individuare bug sempre più complessi. 

In generale è buona norma scrivere i test prima ancora di aver scritto il programma, una tecnica chiamata ``test-driven-develompent''. 
Inoltre è sempre conveniente scrivere esattamente cosa verifica il test nel suo nome, per evitare di creare confusione, e per facilitare ancora di più il suo utilizzo, evitando di controllare 
il suo corpo in caso di fallimento del test. 

\clearpage

\section{Polimorfismo}

\subsection{Interfacce}

In Java i riferimenti sono tipati, ovvero specificano il tipo dell'oggetto referenziato, quindi attraverso un riferimento possono essere eseguiti tutti i metodi offerti dalla 
classe dell'oggetto. In generale nei linguaggi orientati agli oggetti esiste più di un modo per poter creare un tipo, in Java oltre al costrutto \verb|class| esiste il 
costrutto \verb|interface|, utilizzato per creare un nuovo tipo. 
Questo costrutto specifica un tipo in termini dei metodi che può offrire, specificando solamente la segnatura ed il tipo di ritorno, per cui non è presente alcun dettaglio 
implementativo, come le variabili, costruttori ed il corpo dei metodi. Una classe può implementare una o più \verb|interface| tramite il costrutto \verb|implements <nome-interface>|, 
e deve contenere tutti i metodi interni contenuti dall'\verb|interface|, ma può contenete non solo questi metodi. 
Una singola classe può implementare più di un'interfaccia, può assumere quindi più di un singolo ruolo, associato ad ogni singola interfaccia. 


Una classe che implementa un'interfaccia è un suo sottotipo, mentre l'interfaccia è un supertipo, una sua generalizzazione. 
In Java vale il principio di sostituzione di Liskov, il quale afferma che un sottotipo può essere usato al posto di un suo supertipo. 


Per il principio di sostituzione, un riferimento ad un sottotipo può essere assegnato ad un riferimento ad un suo supertipo. La promozione di un tipo ad un suo supertipo viene 
chiamata ``upcasting''. 
Il collegamento tra l'assegnatura e l'implementazione di un'interfaccia non è nota a tempo di compilazione, per cui si chiama ``late binding''. 
Quindi si può differenziare tra il tipo statico, definito a tempo di compilazione, ed il tipo dinamico, ciò che viene utilizzato a tempo di esecuzione. Il compilatore 
permette di applicare solo i metodi del tipo statico, poiché essendo legato solamente a tempo di esecuzione, il compilatore non permette di utilizzare i metodi del tipo 
dinamico. 
Per cui avendo un riferimento tipato staticamente ad un'interfaccia, il metodo da eseguire non è noto a tempo di compilazione, è il suo tipo dinamico che determina il metodo che verrà 
eseguito. Questo tipo di comportamento viene chiamato polimorfo, poiché sono possibili diverse forme o comportamenti diversi per tutti i suoi sottotipi. 

L'overloading dei metodi avviene a tempo di compilazione, quindi staticamente, ma in questo modo non tiene conto dei metodi dei tipi dinamici. 
Il tipo di dichiarato di una variabile è il suo tipo statico, mentre il tipo dell'oggetto referenziato è il suo tipo dinamico. Il compilatore in generale non conosce non può neanche prevedere 
i tipi dinamici. 

Per cui per utilizzare i metodi forniti da un certo tipo, può essere necessario effettuare un ``downcast'', da un supertipo ad un suo sottotipo per permettere al compilatore di utilizzare 
i metodi offerti da questa classe. In questo modo si forniscono informazioni al compilatore ``forzando'' un certo tipo statico. Ma questa operazione eseguita a tempo statico non necessariamente 
è lecita, ovvero non è possibile controllare a tempo statico che il sottotipo assegnato sia un tipo valido. La macchina virtuale controlla quindi a tempo di esecuzione che questa operazione 
sia lecita e possibile. Altrimenti viene sollevata l'eccezione \verb|ClassCastException|. 


Le invocazioni polimorfe si risolvono a tempo di esecuzione sulla base del tipo dinamico da parte della macchina virtuale, mentre il sovraccarico di un metodo viene risolto a tempo di 
compilazione dal compilatore, sulla base del tipo statico dei parametri passati al metodo. 

\subsection{Estensioni e Overriding}

Date due interfacce diverse, aventi gli stessi metodi, anche se concettualmente sembrerebbero uguali, non è possibile contenere un riferimento ad un oggetto che ne implementa una, in un 
tipo che ne implementa l'altra. Per risolvere questo problema viene fornita la parola chiave \verb|extends <nome-interfaccia>| per ``estendere'' un'interfaccia e quindi 
specificare un rapporto di supertipo e sottotipo tra le due, aggiungendo dei metodi non presenti nella prima interfaccia. A tempo di compilazione è quindi possibile 
referenziare due oggetti che implementano queste due interfacce diverse, applicando il principio di sostituzione. 
Attraverso quest'estensione è possibile quindi definire nuovi tipi a partire da tipi già esistenti. 


Oltre alle interfacce, è possibile estendere le classi, ma questo è un meccanismo più complesso, poiché entrambe le classi, supertipo e sottotipo, contengono metodi con un corpo, 
a differenza delle interfacce. La classe di partenza viene chiamata superclasse, o classe base o genitore. La classe definita per estensione da questa, viene chiamata classe estesa, 
derivata, sottoclasse o figlia, quest'ultima può essere estesa creando una ``gerarchia'' di classi. 
La classe derivata ``eredita'' tutto quello che offre la classe di partenza. Tramite l'annotazione \verb|@Override| è possibile modificare un metodo con corpo della superclasse, 
all'interno della classe derivata. 
Per indicare la definizione di una classe come estensione di una classe si usa la stessa parola chiave \verb|extends <nome-classe>|. Queste classi derivata possono dichiarare 
metodi e campi aggiuntivi, e modificare tramite annotazioni metodi preesistenti. La classe base viene considerata un supertipo della classe estesa. Poiché rappresenta una classe 
esterna, non può accedere a parametri privati, interni alla classe base. Per accedere a queste variabili è possibile utilizzare i metodi getter e setter offerti dalla classe 
base, applicati sulla classe derivata. 
Come per le interfacce, non è possibile invocare i metodi privati, di una classe estesa, applicato sulla sua superclasse. 
Il meccanismo di modifica di un metodo presente nella classe base si chiama ``overriding'', tramite annotazioni, come descritto precedentemente. Ma bisogna considerare che non 
può accedere a parti private della superclasse. 

Per cui se dentro la sottoclasse si vuole accedere ai campi della superclasse bisogna utilizzare l'interfaccia pubblica di quest'ultima, come ogni altra classe esterna. 
Un'istanza della classe estesa può essere usata al posto di un'istanza della classe base, manifestando il polimorfismo, quindi la scelta dell'implementazione dei metodi avviene sempre 
a tempo dinamico. 


Per creare un'istanza della sottoclasse è necessario invocare la superclasse corrispondente. Il costruttore di una classe estesa deve quindi inizializzare i propri campi, ed i 
campi propri della superclasse, ma un metodo di una sottoclasse non può accedere a parti private della sua superclasse. In java questo viene risolto delegando questo metodo, 
effettuando una chiamata al costruttore della sua superclasse, per inizializzare le sue parti private. Ciò si effettua tramite la parola chiave \verb|super(<parametri>)|, 
passando i parametri formali che diventano parametri attuali del costruttore della sua superclasse. Questa invocazione deve essere l'unica e sola nel costruttore, e deve 
essere presente alla prima riga del costruttore della sottoclasse. Questo poiché è necessario creare la superclasse prima di poter creare la sua sottoclasse, si è quindi vincolati 
quest'ordine sintattico. 

Se la superclasse non ha costruttori, il compilatore ne crea uno automaticamente senza argomenti, quindi è possibile che aggiungendo un costruttore della superclasse, si 
genera un errore di compilazione su un costruttore della sua sottoclasse, poiché utilizza il costruttore creato automaticamente dal compilatore ``no-arg''. 

Ogni oggetto Java direttamente o indirettamente deve essere un sottotipo della classe \verb|Object|, chiamato anche la radice della gerarchia dei tipi Java.
Tutte le classi estendono automaticamente questa classe predefinita, contiene quindi alcuni metodi disponibili ad ogni classe. 
Alcuni di questi metodi sono \verb|toString()| e \verb|equals(Object o)|, tutte le classi ereditano questa implementazione, oltre la loro segnatura, possono quindi ridefinire 
l'implementazione, rispettando la segnatura. Il metodo \verb|toString()| di default stampa l'indirizzo di memoria dell'oggetto su cui viene applicato il metodo, mentre il metodo \verb|equals()| 
verifica l'uguaglianza dei riferimenti dell'oggetto corrente e del riferimento all'oggetto passato come parametro. 
Quasi sempre quindi conviene ridefinire questi metodi sulla base dello specificità della classe definita, rispettando la segnatura. 
Poiché nel metodo \verb|equals()| la segnatura è di tipo \verb|Object|, bisogna effettuare un downcast quando si vuole ridefinire il metodo, altrimenti non sarebbe possibile invocare 
i metodi propri della classe, poiché il compilatore può controllare solamente il tipo statico. Non è possibile cambiare la segnatura poiché non sarebbe una sovrascrittura del metodo, ma una 
sovraccarico. 
Generalmente quando si ridefinisce un metodo fornito dalla classe \verb|Object| bisogna effettuare un downcast al tipo della classe necessaria nel metodo. 
Essendo tutte le classi estensioni di questa classe predefinita, ogni costruttore contiene implicitamente una chiamata al costruttore alla classe \verb|Object|. 

La parola chiave \verb|super| è in grado di effettuare una chiamata ad un metodo presente nella superclasse, all'interno di una classe avente lo stesso nome nella 
sottoclasse. Impedendo di avere un invocazione ricorsiva dello stesso metodo fino all'esaurimento dello stack. 

\subsection{Modificatori di Accesso}

In Java esiste un altro modificatore di accesso di livello intermedio tra \verb|public| e \verb|private|, chiamato \verb|protected|, permette ad una superclasse aventi 
membri protetti di essere visibili a tutte le sue sottoclassi, indipendentemente dai pacchetti di appartenenza. 
In generale questo modificatore di accesso viene evitato per applicazioni semplici, come lo studio di caso trattato in questo corso, poiché rappresenta uno studio 
introduttivo. Infatti contraddice implicitamente il principio dell'``information hiding''. 
L'utilizzo più opportuno è nella progettazione di framework, librerie che permettono l'estensione da parte degli utilizzatori. 

Il livello di visibilità ottenuto senza inserire un modificatore di accesso viene chiamato anche \verb|package-private|. Questo livello di visibilità è il meno permissivo 
dopo il modificatore \verb|private|. 

\begin{center}
    \begin{tabular}{|c||c|c|c|c|}
        \hline
        Modificatori & Classe & Pacchetto & Sottoclasse & Globale\\
        \hline\hline
        \verb|public| & Sì & Sì & Sì & Sì \\
        \hline
        \verb|protected| & Sì & Sì & Sì & No\\
        \hline
        & Sì & Sì & No & No\\
        \hline
        \verb|private| & Sì & No & No & No \\
        \hline        
    \end{tabular}
\end{center}

In ordine di visibilità decrescente si ha quindi \verb|public|, \verb|protected|, \verb|package-private| e \verb|private|. 


Solo i metodi visibili alle sottoclassi possono quindi essere sovrascritti, altrimenti se se viene sovrascritto un metodo privato della superclasse, quello nella sottoclasse nasconde 
l'omonimo della superclasse, ma non lo sovrascrive. Inoltre è possibile sovrascrivere la visibilità di un metodo, solamente mantenendo la stessa o ampliandola, rispettando quindi 
l'analogo del principio di sostituzione per la visibilità. 
Sovrascrivendo un metodo è possibile modificare la sua visibilità, rendendolo più visibile, ma non è possibile diminuire la visibilità di uno metodo da una sottoclasse. 
Il metodo di una sottoclasse può modificare un metodo, ereditato dalla superclasse, di identica segnatura ma di tipo restituito più generale. Questa caratteristica si chiama 
covarianza. 
Mentre si può effettuare un procedimento analogo con parametri polimorfi, dove bisogna posizionare nel supertipo il parametro più specifico mentre nel sottotipo il parametro 
più generico. Questa caratteristica si chiama controvarianza. 
Entrambi tendono a generalizzasi o specializzarsi salendo o scendendo nella gerarchia delle classi. 
Per cui il parametro passato è controvariante, mentre il parametro restituito è covariante; scendendo nella gerarchia dei tipi, i parametro passati devono essere sempre 
più generali, mentre i parametri restituiti sempre più specifici. 

Poiché in Java due metodi aventi lo stesso tipo rappresentano un sovraccarico, questo tipo di overload viene risolto a tempo statico, ma secondo il paradigma orientato 
agli oggetti questo rappresenta una sovrascrittura, nonostante siano due metodi che prendono due parametri distinti polimorfi. Quindi utilizzando la parola chiave \verb|@Override| 
viene generata un eccezione a tempo di compilazione. 
Senza quest'annotazione, la sottoclasse dispone di due metodi distinti e sovraccarichi, la cui invocazione dipende dal tipo statico del parametro passato. 

La visibilità ed il tipo di parametro sono controvarianti, mentre il tipo restituito è covariante con la gerarchia delle classi. 


In Java la gerarchia delle classi ha una radice definita, è quindi \verb|java.lang.Object|, e rappresenta la radice predefinita della gerarchia delle classi. 
Al contrario di altri linguaggi di programmazione, come C++, in Java, non è possibile avere una derivazione multipla tra classi, una classe può quindi estendere al più una 
sola altra classe, e può avere zero o più sottoclassi. 


Nei linguaggi con derivazione multipla, se in due classi base un metodo viene definito, nella sottoclasse, non è definito quale delle due implementazioni da ereditare, se non entrambe. 
Questo problema viene risolto nei linguaggi di programmazione dove è presente la gerarchia multipla, ma la sua utilità è limitata a pochi casi. 

In Scala questo problema viene risolto creando un'ordine totale, tramite un processo di linearizzazione della gerarchia in base a quale tipo viene prima all'interno. 
Se un membro è definito in entrambi le classi base, la classe estesa da queste due mischia le due implementazioni. Quando le due classi non presentano membri che 
si sovrappongono tra di loro è possibile unire le due classi poiché non si presentano conflitti. 

In Java invece è possibile effettuare una derivazione multipla tra interfacce, la stessa classe \verb|String| implementa tre interfacce. Questo è possibile poiché non è 
possibile mischiare il corpo dei metodi forniti dalle interfacce, dato che vengono implementati all'interno della classe che le estende. 
La gerarchia dei tipi non è più lineare, poiché comprende anche le interfacce, che possono estendere zero o più interfacce, mentre le classi possono implementare zero o più 
interfacce. 
La gerarchia delle classi è lineare, mentre la gerarchia delle interfacce non è lineare. In Java 8 vennero introdotti i metodi default, che permettono una derivazione multipla 
ristretta, per poter estendere librerie senza perdere la retrocompatibilità. 


La scelta dei corretti tipi da definire in un programma è un delicato esercizio di modellazione. Nella creazione dei tipi occorre considerare anche gli aspetti dinamici. 


Il sovraccarico di un metodo viene risolto a tempo di compilazione in Java, sulla base dei tipi statici, ma è possibile ottenere un effetto simile ad un sovraccarico sulla base 
di tipi dinamici, utilizzando una chiamata polimorfa ed il late-binding. 

%% TODO barba-trucco  ovverriding for overloading
Si considera una gerarchia di tipi, avente come radice una interfaccia vuota non modificabile, e si considera un metodo che vuole essere implementato sull'interfaccia. 
Si potrebbe creare quindi una classe contenente metodi sovraccarichi per quante sono le classi che implementano tale interfaccia. Ma questo è possibile solamente quando si 
coincide il tipo statico con il tipo dinamico delle variabili locali delle classi, passati ai metodi sovraccarichi. Altrimenti non sarebbe possibile utilizzare questa tecnica, 
spesso invece non è nota il tipo dinamico del parametro passato al metodo. 
Per risolvere questo problema quindi bisogna trovare un modo per passare un tipo generico a questo metodo, basandosi solamente sul tipo statico. Si vuole risolvere il metodo 
sovraccarico sulla base del tipo dinamico.  

In generale è sconsigliato determinare il tipo dinamico di un oggetto tramite il codice, poiché il polimorfismo deve chiamare il metodo corretto in base al tipo dinamico, per 
cui in questo caso non si considera questa tecnica. 

Il vantaggio delle chiamate polimorfe è che permettono di scegliere quale metodo da invocare sulla base del tipo dinamico, per cui modificando la definizione di codice della 
libreria che implementa l'interfaccia vuota, per ospitare un metodo che accetta una classe, contenente metodi sovraccarichi per ogni sottoclasse dell'interfaccia. 
In seguito si inserisce in ogni sottoclasse un'implementazione di questo metodo come override che invoca questo metodo sovraccarico, passando sé stesso con la parola chiave 
\verb|this|, tipo statico il tipo della classe o il suo sottotipo. In questo modo la chiamata polimorfa sovrascritta in una sottoclasse generica dell'interfaccia iniziale 
invoca un metodo dove il tipo statico corrisponde al tipo dinamico. 

%% TODO esempio pratico (forme_geometriche) / ppt. 

Questa tecnica si chiama ``dispatching''. 

\clearpage

\section{Generics}

I generics sono uno strumento per scrivere classi e metodi parametriche rispetto ad un tipo. Più che progettare classi generiche, si vuole utilizzare classi generiche, la loro 
progettazione va oltre gli obiettivi del corso. Per classe generica si intende un tipo che dipende da un altro tipo. In questo corso si useranno classi generiche relative 
alla gestione di collezioni di oggetti, in particolare con il pacchetto \verb|java.util|. 

Senza utilizzare classi generiche per poter realizzare tipi parametrici, consiste nello sfruttare il polimorfismo, utilizzando la classe \verb|Object| ed utilizzando il 
principio di sostituzione per poter ottenere l'effetto desiderato, essendo la radice della gerarchia delle classi. Prima di Java 5, questo era l'unico metodo di programmazione 
fornita da Java, utilizzando downcast sparsi nel codice. Questo controllo lasco dei tipi potrebbe portare ad errori a tempo di esecuzione. 
Questo rappresenta solamente un'approssimazione del tipo desiderato. 


Introdotti in Java 5, i generics sono uno strumento per scrivere classi ed interfacce il cui tipo diventa parametrico rispetto ad uno o più tipi. Il tipo generico dipende 
da un tipo chiamato formale, che deve essere istanziato affinché funzioni correttamente. I tipi formali in generale vengono chiamati con singole lettere maiuscole, 
per indicare che una classe è un generics si utilizza la notazione accanto al tipo del nome della classe \verb|< >|, che racchiude il nome del tipo formale. 
Questo tipo viene usato come una dichiarazione di tipo, quindi può essere usato all'interno della classe come instanziamento di tipo. Solo quando viene creato il tipo 
bisogna assegnare un tipo al tipo formale, se non vengono forniti tutti i tipi formali il codice non compila. 

Quando si uas una classe generica, bisogna istanziarne completamente i tipi fornendo i tipi attuali di tutti i tipi formali di cui fa uso, solo in questo modo può essere 
utilizzata come un tipo. 

Il concetto tra parametro attuale parametro formale è simile alla relazione tra tipo formale e tipo attuale. 

Essendo Java un linguaggio ibrido sono presenti informazioni, non rappresentate come oggetti, per cui non è possibile utilizzare questi tipi come tipi formali di una classe 
generica. Non è possibile istanziare i tipi di una classe, di una interfaccia o di un metodo generico con tipi primitivi. Per risolvere questo problema è possibile 
rappresentare i tipi primitivi mediante le classi ``wrapper''. Per ogni tipo primitivo esiste una corrispondente classe wrapper che consente di esprimerlo tramite oggetto, 
immutabile, costruendoci un oggetto attorno. 

Le classi wrapper sono definite nel pacchetto \verb|jav.lang|, per cui non è necessario importarle, esplicitamente. Per ovviare a questa eccessiva verbosità, da 
Java 4, la gestione degli oggetti wrapper venne semplificata tramite tecniche di ``boxing'' e ``unboxing''. Che permettono di effettuare dichiarazioni, inizializzazioni e 
conversioni dirette tra tipi primitivi ad oggetti wrapper. 


%% TODO 24/4: wildcard ppt. 


La sintassi di questa wildcard viene rappresentata da \verb|?|, per indicare che si può accettare un parametro di tipo \verb|T| o sottotipo di \verb|T| si usa quindi la 
segnatura \verb|<? extends T>|. 
Il compilatore decide a tempo di compilazione il tipo attuale dei tipi formali della classe generica. Questo uso uso di wildcard rappresenta un ``limite'' superiore 
rispetto alla gerarchia dei tipi, per definire quali tipi sono accettabili dalla classe. 

Delle classi non generiche possono ospitare metodi statici generici, inserendo il tipo formale subito prima del tipo restituito. Questo metodo può essere evocato 
come per le classi generiche solo se il tipo formale è perfettamente definito. 

Analogamente si può indicare un limite superiore tramite la segnatura \verb|<? super T>|, in questo modo si può accettare un parametro di tipo \verb|T| o di un suo 
supertipo. 

Per determinare quale tipo attuale rappresenta il tipo formale si considera la regola PECS, %% TODO convenzione PECS

I tipi generici si usano per lavorare con le collezioni, presenti in \verb|java.util.Collection|. 
Quando non è strettamente necessario dare un nome al tipo formale si utilizza la sintassi \verb|<?>|. 


\subsection{Collezioni}

Il linguaggio offre delle librerie native, utilizzate per implementare collezioni come liste, mappe, tabelle di hash, etc. 
Tutti queste collezioni appartengono al ``Collection Framework''. 


Molte applicazioni richiedono di gestire collezioni di oggetti, gli array, usati dall'inizio del corso sono un strumento di basso livello. La dimensione di una collezione 
generalmente non è nota a priori, e gli array non permettono di variare la sua dimensione, per cui è possibile sia necessario creare un array di dimensione maggiore, per 
evitare un overflow. 

Inizialmente venne introdotto in Java 2, ma venne esteso in Java 5, con l'introduzione dei Generics, introdotti appunto per generalizzare il loro uso nelle collezioni 
preesistenti. 
Viene contenuto nel pacchetto \verb|java.util|, contiene collezioni non specialistiche, tra le più utilizzate in assoluto. 

Il Java Collection Framework (JCF), contiene implementazioni interfacce, come le liste e le mappe. Collezioni utilizzate in tutti i linguaggi di programmazione moderni, 
generiche, dipendenti le liste da un tipo formale, mentre le mappe, dizionari, array associativi dipendono da due tipi formali, una chiave ed il valore. 
Altre interfacce permettono di enumerare la collezione indipendentemente dal tipo della stessa. 

L'interfaccia \verb|Collection<E>| dichiara una generica collezione, generalizzata sia su \verb|List<E>| che su \verb|Set<E>|. Nelle liste gli elementi sono salvati sequenzialmente 
e possiedono una posizione, senza gestire i duplicati; mentre negli insiemi, non ammettono duplicati e gli elementi non possiedono una posizione. 

Dentro questa interfaccia sono presenti quindi tutti i metodi utili da applicare a collezioni di elementi, che essi siano liste o insiemi. Questi metodi effettuano operazioni 
come l'aggiunta e la rimozione di elemento, verificare la dimensione o se è vuota, aggiungere tutti gli elementi ad un'altra collezione, ed ottenere un iteratore con cui 
è possibile scandire la collezione. 


L'interfaccia \verb|Set<E>| estende \verb|Collection<E>|, è una collezione che non può contenere duplicati. Questa collezione offre tutti e soli i metodi dell'interfaccia 
\verb|Collection|. 
Poiché non ammettono duplicati, è necessario definire un criterio di equivalenza tra due elementi dell'insieme, in modo da utilizzarlo come criterio per rifiutare aggiunte 
all'insieme. 

L'interfaccia \verb|List<E>| estende \verb|Collection<E>| corrisponde ad una sequenza ordinata di elementi. Ogni elemento può quindi essere identificato dalla sua posizione. 

L'interfaccia \verb|Map<K,V>| offre le operazioni di una mappa, o dizionario; è una collezione di coppie chiave-valore. 

La classe \verb|java.util.Collections|, offre un vasto insieme di metodi statici generici, %% TODO metodi offerti dalla classe Collections


I metodi offerti dall'interfaccia \verb|Collection<E>| vengono usati per una collezione generica, permettono di svolgere tre categorie di operazione:
\begin{itemize}
    \item Manipolazione di base;
    \item Bulk;
    \item Conversione di/ad un array. 
\end{itemize}

Tutti i metodi che producono un effetto scontato, o non producono alcun effetto collaterale vengono implementati utilizzando il tipo \verb|Object| per il tipo passato. 
Mentre metodi che necessitano di un tipo specifico, altrimenti si provocano effetti indesiderati, vengono tipati utilizzando il tipo specifico per il tipo passato, come per il 
tipo \verb|add|.
Il metodo \verb|add| restituisce un booleano, vero se e solo se l'aggiunta ha generato una modifica della collezione. 


I metodi con la variante di suffisso \verb|All| permettono di effettuare addizioni rimozioni a ``lotto''. Hanno una segnatura strettamente collegata ai metodi basici, 
prendono come parametro il tipo \verb|Collections<?>|. Tutti questi i metodi sono lascamente tipati, eccetto \verb|addAll|, che richiede una collezione di tipo \verb|<E>| o di 
un suo sottotipo. 

La conversione ad un array viene tipata come un array di oggetti \verb|Object[]|, mentre è possibile effettuare la stessa ad un metodo parametrico \verb|toArray(T[] a)|, che 
prende un array dichiarato esternamente da riempire, e ne prende il tipo. 
Uno dei motivi per la presenza di questi metodi, consiste nella creazione di questo pacchetto precedentemente ai Generics in Java 5. Inoltre la seconda versione, che costringe di 
specificare il tipo, permette al compilatore di effettuare un'analisi statica dei tipi più stretta, senza che sia il compilatore a cercare il tipo dalla collezione, poiché 
per motivi di retrocompatibilità non è possibile realizzare array generici in Java, appunto per l'introduzione tardiva dei Generics. Poiché i Generics vengono utilizzati a 
tempo di compilazione, e non è possibile identificare a tempo di esecuzione quale metodo o classe sia generica o meno. 

Per utilizzare il secondo tipo per generare un array generico, si può passare come parametro un array lungo zero, in modo da passare il tipo, ed è il metodo a creare un array 
dello stesso tipo, di lunghezza sufficiente per ospitare tutta la collezione. 

\subsection{Iteratori}

Storicamente ogni collezione diversa richiedeva un modo diverso per scandire la collezione, per ogni collezione si generava un modo di enumerare gli elementi della collezione. 
Il codice per enumerare gli elementi dipendeva fortemente dalla collezione stesa. Gli iteratori rappresentano uno stesso modo per poter enumerare elementi di collezioni diverse 
tra di loro. 
Si è quindi oggettificato il concetto di enumerazione di una collezione, indipendentemente dal tipo della collezione ospitante di questi elementi. Gli iteratori 
sono creati invocando il metodo \verb|iterator()| sulla collezione. 

In pratica è un cursore che scandisce la collezione sottostante ricordando la sua posizione nella scansione. Una posizione lecita si trova subito prima o subito dopo di un 
elemento della collezione su cui si sta iterando, non si trova mai sopra un elemento. 

I metodi verificano se l'elemento corrente ha un successivo, ed il metodo che restituisce il riferimento a quest'elemento con \verb|hasNext()| ed \verb|next()|. 
Rappresenta un'enumerazione con stato, poiché deve salvare il suo stato attuale. Se si arriva alla fine della collezione, chiamando il metodo \verb|next()| viene 
sollevata un'eccezione. 

% per imparare il comportamento di iteratore tramite test di iteratori. 

Da Java 7 in poi, data una variabile che può ospitare una collezione rispetto ad una classe formale, nella dichiarazione della collezione si può omettere il tipo formale, e 
lasciare \verb|<>| vuoto. 

%% TODO esercizio iterazione, scansione di list con for-each


Un iteratore per effettuare il suo lavoro deve conservare un rifermento alla collezione che lo ha creato su cui vuole iterare, successivamente alla sua creazione. 
La presenza di un metodo \verb|remove()| rende più evidente la natura di questo legame. Rimuove l'ultimo elemento restituito dalla chiamata \verb|next()|, l'ultimo 
elemento restituito dalla collezione. Viene introdotto questo metodo per permettere all'iteratore di conoscere lo stato della collezione dopo la rimozione, poiché è 
passata attraverso l'iteratore. 
Ovviamente chiamate successive a questo metodo senza ulteriori chiamate a \verb|next()| producono un errore. Invece se viene chiamato il metodo \verb|remove()| sulla 
collezione, il comportamento dell'iteratore non è scontato. 
Alcuni iteratori conservano la collezione precedente, altri si aggiornano, altri ancora forniscono un errore. 
La documentazione dell'interfaccia specifica che il suo comportamento non è specificato se la collezione viene modificata quando l'iteratore sta ancora iterando sulla collezione. 
Generalmente applica la strategia del ``fail fast'', ed alla prima chiamata al metodo dell'iteratore dopo una modifica alla collezione solleva un'eccezione \verb|ComponentModificationException|
Per verificare se la collezione è stata cambiata, la collezione genetrice crea un oggetto che salva la versione corrente della collezione, aggiornata ad ogni modifica 
della collezione. Questo oggetto viene quindi controllato dall'iteratore per verificare che la collezione non è stata modificata. 
Nella documentazione viene sconsigliato l'affidamento su questo oggetto, poiché conserva la versione in un intero, che può contenere al massimo quattro miliardi di modifiche 
alla collezione, prima di effettuare un overflow, e ritornare al valore iniziale. 

\subsection{Liste}

Le liste sono strutture dati astratte, con aggiunta in coda, tramite il metodo \verb|add()|. Gli elementi vengono salvati sequenzialmente, e vengono indicizzati a partire
da zero, come per gli array. Si può accedere ad un elemento specifico per indice, e cercare l'indice tramite metodi presenti. 

Il package \verb|java.util| offre due implementazioni dell'interfaccia \verb|List<E>|:
\begin{itemize}
    \item \verb|ArrayList<E>|;
    \item \verb|LinkedList<E>|.
\end{itemize}
Gli \verb|ArrayList<E>| hanno un'aggiunta molto efficiente per indice, ma avendo una lunghezza fissa, quando l'array è pieno, bisogna creare un array nuovo di grandezza 
superiore. 
Per cui le sue prestazioni sono strettamente dipendenti dalla dimensione attuale del numero dei dati salvati. 


In generale la rappresentazione \verb|LinkedList<E>|, di liste concatenate, ad una o due sentinelle, permettono una dimensione variabile, ma gli accessi 
avvengono sequenzialmente, per cui hanno un tempo lineare, al contrario degli \verb|ArrayList<E>|, in tempo costante eccetto il trabocco. 


I costruttori di queste due implementazioni sono sovraccarichi. Entrambi hanno un costruttore vuoto, ed un costruttore che prende come parametro una collezione di un sottotipo 
del tipo formale \verb|E|: \verb|Collections<? extends E>|, permettendo di convertire un'intera collezione in una lista. Viene inserito il sottotipo poiché le collezioni 
non sono covarianti con il tipo della stessa. 


Per \verb|LinkedList| sono presenti dei metodi per accesso in testa e coda, poiché avviene in tempo costante, tramite riferimenti alla testa ed alla coda. 


Nella classe \verb|Collections| sono presenti vari metodi efficienti per ordinare la lista, per effettuare una ricerca binaria, cercare il massimo o minimo nella lista. 
Queste operazioni sono possibili solamente se esiste una relazione d'ordine tra gli elementi presenti nella collezione. 
Quest'operazione viene affidata all'apposita interfaccia \verb|java.lang.Comparable<E>|, naturale o interno, oppure ad una classe esterna agli oggetti contenuti tramite 
l'interfaccia \verb|java.util.Comparator<T>|. 
La prima interfaccia consiste nell'unico metodo \verb|public int compareTo(T that)|, e restituisce un valore minore maggiore o uguale a zero a seconda che l'oggetto 
\verb|this| su cui viene applicato il metodo sia rispettivamente minore, maggiore o uguale al riferimento all'oggetto ricevuto come parametro. 

Molte librerie standard già implementano quest'interfaccia, adottando una semantica scontata. Viene eventualmente delegato quindi ad una di queste implementazioni, quando si vuole 
implementare l'interfaccia su un altra classe. 

\subsubsection{Ordinamento Interno}

Il metodo per ordinare le liste corrisponde al metodo statico \verb|Collections.sort()|, in due versioni sovraccariche corrispondente ai due metodi per determinare un 
criterio di ordinamento. La segnatura per l'ordinamento naturale corrisponde a:
\begin{minted}{java}
    public static <T extends Comparable<? super T>> void sort(List<T> list)
\end{minted}
Affinché qualcosa sia ordinabile, deve implementare un criterio di ordinamento. Questo criterio di ordinamento deve essere in grado di ordinare un tipo o un suo supertipo. 

Per ottenere un minimo o un massimo da una lista \verb|List<T>|, i cui elementi implementano l'interfaccia \verb|Comparable<T>|, può essere calcolato mediante i metodi offerti 
da \verb|Collections|:
\begin{minted}{java}
public static <T extends Object & Comparable<? Super T>> T min/max(Collections<? extends T> c)
\end{minted}
Per gli stessi motivi del precedente metodo. Semplificato in:
\begin{minted}{java}
    public static <T extends Comparable<? Super T>> T min/max(Collections<? extends T> c)
\end{minted}
Questo metodo non compila, se i metodi statici non risultano avere i metodi necessari per comparare, a tempo di compilazione, e quindi rappresenta un'enorme vantaggio 
di Java. L'analisi dei tipi è uno strumento in grado di individuare errori anche a tempo di compilazione. 

Se si ha una gerarchia dei tipi, è possibile implementare l'interfaccia \verb|Comparable<T>| solamente su un unico tipo, poiché a tempo di compilazione vengono utilizzati, e 
rimpiazzati con tipi attuali a tempo di esecuzione, per la necessità di mantenere la retrocompatibilità di Java. Per questo un'unica gerarchia può avere un'unica 
implementazione di un'interfaccia. Si rifiuta di considerare due instanziamenti dello stesso tipo generico con due tipi attuali diversi, poiché nel file \verb|.class| si avrebbero 
due \verb|Comparable| che riferiscono a due tipi diversi, creando confusione. 
Per lo stesso motivo non è possibile generare un array generico in Java. 

Per questi motivi si preferisce mantenere un ordinamento naturale per tipi semplici, e si evita di utilizzarlo su una gerarchia per non ``sprecare'' il suo utilizzo. Per cui 
risulta ben motivato l'utilizzo di classi esterne per implementare l'ordinamento. 

\subsubsection{Ordinamento Esterno}

L'ordinamento esterno viene consiste nell'utilizzo dell'interfaccia \verb|java.util.Comparator<T>|, composta da un'unico metodo:
\begin{minted}{java}
public int compare(T o1, T o2)
\end{minted}
Che deve restituire un valore minore, maggiore o uguale, a seconda se l'oggetto riferito da \verb|o1| sia minore, maggiore o uguale all'oggetto riferito da \verb|o2|. 

In \verb|Collections| esistono metodi per il calcolo del massimo e del minimo, secondo l'ordinamento esterno:
\begin{minted}{java}
static <T> T min/max(Collections<? extends T> c, Comparator <? super T> comp)
\end{minted}

\subsection{Insieme}

%% TODO 6/5: Insiemi

L'interfaccia \verb|Set<E>| rappresenta un insieme, le due classi più famosi che lo implementano sono \verb|HashSet<E>| e \verb|TreeSet<E>|, un insieme ``ordinato''. 

Gli insiemi sono collezioni che non contengono duplicati. Offre tutti e soli i metodi dell'interfaccia \verb|Collection<E>| con la restrizione che le classi che la 
implementano non contengono duplicati. 
Per poter riconoscere duplicati, bisogna definire un criterio di equivalenza tra gli elementi, basato sul dominio di utilizzo. 
Per stabilire il criterio di equivalenza si può utilizzare il metodo \verb|equals()|, ed anche il metodo \verb|hashCode()|, per la classe \verb|HashSet<E>|. 
Questi due metodi gemelli sono entrambi necessari per verificare ed evitare la presenza di duplicati nell'insieme. 

Nel caso di \verb|TreeSet<E>|, ed in generale di insiemi ordinati, è necessario un criterio di ordinamento, naturale tramite \verb|Comparable<E>|, oppure passando al 
momento della costruzione un oggetto \verb|Comparator<E>| esterno. 

\subsubsection{HashSet}

Una funzione hash è una funzione che calcola un numero intero, detto codice hash, a partire da un oggetto, in grado di verificare se due oggetti sono diversi o uguali, 
poiché due oggetti aventi lo stesso codice hash saranno certamente equivalenti, mentre molto probabilmente due oggetti non equivalenti possiedono codici hash diversi. 
Quando due oggetti non equivalenti hanno lo stesso codice hash, è necessario interrogare il metodo \verb|equals()|, questo fenomeno si chiama collisione; in generale 
si prediligono funzioni di hash che minimizzano le collisioni. 

Una tavola hash rappresenta un array, dove ogni elemento occupa una posizione corrispondente al suo codice hash, quando viene raggiunta la dimensione massima dell'array, 
viene copiato in una array di lunghezza doppia. 
Per risolvere il problema delle collisioni viene realizzato come un array di liste di conflitto, dove ogni elemento rappresenta una lista a tutti gli elementi ospitati 
nella tabella di hash aventi lo stesso codice di hash. 

Se la funzione è bene definita, le operazioni di appartenenza, rimozione ed inserimento avvengono in tempo costante. 

Le implementazioni degli insiemi e delle mappe si basano interamente sulle tavole hash. 
Quando si vuole implementare un \verb|HashSet<E>|, tutti gli oggetti della collezione, di tipo formale \verb|E|, devono avere sia il metodo \verb|hashCode()| che il metodo 
\verb|equals()|. 
Se non vengono definiti, vengono ereditati da \verb|java.lang.Object|, in cui il codice di hash corrisponde all'indirizzo di memoria dell'oggetto, ed il metodo \verb|equals()| 
confronta gli indirizzi di memoria. 

Il metodo \verb|equals()| definito deve rispettare le proprietà riflessiva, transitiva e transitiva, inoltre deve restituire falso quando gli viene passato un riferimento nullo, 
mentre quando confronta lo stesso oggetto, deve restituire vero. L'unica asimmetria consiste nel chiamare il metodo su un riferimento nullo, genera infatti una 
\verb|NullPointerException|. Una volta definito questo metodo, il metodo \verb|hashCode()| insiste sugli stessi campi del metodo precedente. 
L'equivalenza di un metodo primitivo, non viene delegata al metodo \verb|equals()| come per i metodi non primitivi, ma viene verificato tramite la sintassi \verb|==|, questa 
rappresenta una piccola ineleganza del linguaggio Java, nella sua gestione dei metodi primitivi. 

Appena viene aggiunto un nuovo elemento alla collezione, questa chiama li metodo \verb|hashCode()| per verificare se non è presente alcun numero di stesso codice hash, 
altrimenti invoca il metodo \verb|equals()| su ogni elemento della lista di collisione. 
Questi due metodi sono assolutamente indipendenti l'uno dall'altro, e permettono facilmente di realizzare implementazioni molto efficienti. 
Per ottenere implementazioni più efficienti, i calcoli effettuati dal metodo \verb|hashCode()| devono essere molto meno onerosi del metodo \verb|equals()|, poiché il primo 
metodo viene invocato sempre, mentre il secondo solo in caso di collisioni. 

Se non venisse implementato il metodo \verb|hashCode()|, si erediterebbe quello definito da \verb|java.lang.Object|. 

%% TODO ppt. sui metodi hashCode e equals

\subsubsection{TreeSet}

L'implementazione più popolare degli alberi ordinati, viene realizzato tramite alberi ordinati, attraverso i metodi di ordinamento naturali ed esterni, definiti precedentemente 
per le liste ordinate. 

Tutto quello trattato sulle liste vale allo stesso metodo per gli insiemi ordinati. 
Garantisce che gli elementi siano posizionati secondo un dato ordinamento. 
Se gli elementi non implementano \verb|Comparable<E>|, o non viene passato in fase di costruzione un oggetto \verb|Comparator<E>|, si può sollevare un errore a tempo di 
esecuzione. 
Vengono implementati tramite alberi di ricerca binari, per uci è necessario che gli elementi possano essere confrontati ed ordinati. Per motivi di retrocompatibilità, 
è possibile realizzare un \verb|TreeSet| di oggetti non ordinabili, ma alla prima occasione, a tempo di occasione, verrà sollevato un eccezione, poiché gli elementi non possono 
essere ordinati. 

%% TODO caratteristiche TreeSet

Se viene definito un criterio di ordinamento, implicitamente viene definito un criterio di equivalenza. Si definiscono i metodi di ordinamento in accordo con i metodi 
\verb|hashCode()| e \verb|equals()|. 
%% Il principio di sostituzione è valido se

%% TODO 8/5: Mappe

Da Java 6 in poi furono introdotte nuove implementazioni di un insieme, specializzata di \verb|SortedSet<E>|, l'interfaccia \verb|NavigableSet<E>|, contenente i metodi per poter 
accedere all'elemento in cima o in coda all'insieme, e per poter accedere agli elementi in ordine invertito. 
\verb|TreeSet<E>| infatti implementa entrambe queste interfacce. Per la retrocompatibilità è stato necessario inserire un metodo sovraccarico \verb|headSet| che restituisce 
un \verb|SortedSet<E>|, con una segnatura asimmetrica rispetto all'originale \verb|headSet()|, poiché restituisce un \verb|NavigableSet<E>| e richiede un valore booleano per 
definire il criterio di uguaglianza. 

\subsection{Mappe}

Una mappa o dizionario o array associativo rappresenta un insieme di elementi formati da coppie di due tipi formali \verb|<K,V>|, dove \verb|K| rappresenta la chiave ``Key'', 
e \verb|V| rappresenta il valore ``Value'', dove gli accessi sono particolarmente efficienti se vengono effettuati per chiave. 

Ad ogni chiave può essere associato un unico valore. 

I metodi base per accedere, aggiungere e rimuovere elementi sono \verb|put()| che richiede una chiave ed un valore di tipo \verb|K| e \verb|V| rispettivamente, oppure 
aggiorna il vecchio valore e lo restituisce, se la chiave era già usata. 
Il metodo \verb|get()| richiede un oggetto di tipo \verb|Object|, per cui è lascamente tipato, sia per mantenere la retrocompatibilità sia per offrire una risposta istantanea 
in caso il tipo non corrisponda al tipo formale \verb|V|. 

%% TODO metodi di base ppt. 

I metodi bulk oltre a \verb|putAll()| e \verb|clear()| usati per aggiungere o eliminare tutte le coppie in una mappa, mentre per ottenere un insieme delle chiavi, si utilizza 
\verb|keySet()|, poiché tutte le chiavi sono uniche nell'intera mappa; mentre se si vuole restituire l'insieme di valori, questi possono essere duplicati quindi il tipo 
di ritorno è lascamente tipato come una qualsiasi collezione del tipo formale \verb|V|, offerto dal tipo \verb|values()|. 

Le mappe e gli insiemi si basano su concetti molto simili, infatti in realtà l'implementazione di \verb|HashSet<K>| si basa su un'istanza di \verb|HashMap<K,?>|. 
%% TODO ppt. 

Per definire il criterio di equivalenza sulle chiavi 
%% TODO implementazioni criterio di equivalenza chiavi in HashMap




\end{document}